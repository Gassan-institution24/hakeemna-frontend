{"version":3,"file":"static/js/9454.d7340f12.chunk.js","mappings":"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","sources":["../node_modules/date-fns/_lib/assign/index.js","../node_modules/date-fns/_lib/cloneObject/index.js","../node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js","../node_modules/date-fns/_lib/toInteger/index.js","../node_modules/date-fns-tz/esm/_lib/tzTokenizeDate/index.js","../node_modules/date-fns-tz/esm/_lib/newDateUTC/index.js","../node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js","../node_modules/date-fns-tz/esm/_lib/tzPattern/index.js","../node_modules/date-fns-tz/esm/toDate/index.js","../node_modules/date-fns-tz/esm/zonedTimeToUtc/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assign;\nfunction assign(target, object) {\n  if (target == null) {\n    throw new TypeError('assign requires that input parameter not be null or undefined');\n  }\n  for (var property in object) {\n    if (Object.prototype.hasOwnProperty.call(object, property)) {\n      ;\n      target[property] = object[property];\n    }\n  }\n  return target;\n}\nmodule.exports = exports.default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneObject;\nvar _index = _interopRequireDefault(require(\"../assign/index.js\"));\nfunction cloneObject(object) {\n  return (0, _index.default)({}, object);\n}\nmodule.exports = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getTimezoneOffsetInMilliseconds;\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nfunction getTimezoneOffsetInMilliseconds(date) {\n  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n  utcDate.setUTCFullYear(date.getFullYear());\n  return date.getTime() - utcDate.getTime();\n}\nmodule.exports = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toInteger;\nfunction toInteger(dirtyNumber) {\n  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {\n    return NaN;\n  }\n  var number = Number(dirtyNumber);\n  if (isNaN(number)) {\n    return number;\n  }\n  return number < 0 ? Math.ceil(number) : Math.floor(number);\n}\nmodule.exports = exports.default;","/**\n * Returns the [year, month, day, hour, minute, seconds] tokens of the provided\n * `date` as it will be rendered in the `timeZone`.\n */\nexport default function tzTokenizeDate(date, timeZone) {\n  var dtf = getDateTimeFormat(timeZone)\n  return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date)\n}\n\nvar typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5,\n}\n\nfunction partsOffset(dtf, date) {\n  try {\n    var formatted = dtf.formatToParts(date)\n    var filled = []\n    for (var i = 0; i < formatted.length; i++) {\n      var pos = typeToPos[formatted[i].type]\n\n      if (pos >= 0) {\n        filled[pos] = parseInt(formatted[i].value, 10)\n      }\n    }\n    return filled\n  } catch (error) {\n    if (error instanceof RangeError) {\n      return [NaN]\n    }\n    throw error\n  }\n}\n\nfunction hackyOffset(dtf, date) {\n  var formatted = dtf.format(date).replace(/\\u200E/g, '')\n  var parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted)\n  // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed\n  // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]\n  return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]]\n}\n\n// Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used\n// to get deterministic local date/time output according to the `en-US` locale which\n// can be used to extract local time parts as necessary.\nvar dtfCache = {}\nfunction getDateTimeFormat(timeZone) {\n  if (!dtfCache[timeZone]) {\n    // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`\n    var testDateFormatted = new Intl.DateTimeFormat('en-US', {\n      hour12: false,\n      timeZone: 'America/New_York',\n      year: 'numeric',\n      month: 'numeric',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n    }).format(new Date('2014-06-25T04:00:00.123Z'))\n    var hourCycleSupported =\n      testDateFormatted === '06/25/2014, 00:00:00' ||\n      testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00'\n\n    dtfCache[timeZone] = hourCycleSupported\n      ? new Intl.DateTimeFormat('en-US', {\n          hour12: false,\n          timeZone: timeZone,\n          year: 'numeric',\n          month: 'numeric',\n          day: '2-digit',\n          hour: '2-digit',\n          minute: '2-digit',\n          second: '2-digit',\n        })\n      : new Intl.DateTimeFormat('en-US', {\n          hourCycle: 'h23',\n          timeZone: timeZone,\n          year: 'numeric',\n          month: 'numeric',\n          day: '2-digit',\n          hour: '2-digit',\n          minute: '2-digit',\n          second: '2-digit',\n        })\n  }\n  return dtfCache[timeZone]\n}\n","/**\n * Use instead of `new Date(Date.UTC(...))` to support years below 100 which doesn't work\n * otherwise due to the nature of the\n * [`Date` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years.\n *\n * For `Date.UTC(...)`, use `newDateUTC(...).getTime()`.\n */\nexport default function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {\n  var utcDate = new Date(0)\n  utcDate.setUTCFullYear(fullYear, month, day)\n  utcDate.setUTCHours(hour, minute, second, millisecond)\n  return utcDate\n}\n","import tzTokenizeDate from '../tzTokenizeDate/index.js'\nimport newDateUTC from '../newDateUTC/index.js'\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\n\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-]\\d{2}):?(\\d{2})$/,\n}\n\n// Parse various time zone offset formats to an offset in milliseconds\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token\n  var absoluteOffset\n\n  // Empty string\n  if (!timezoneString) {\n    return 0\n  }\n\n  // Z\n  token = patterns.timezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  var hours\n\n  // ±hh\n  token = patterns.timezoneHH.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n\n    if (!validateTimezone(hours)) {\n      return NaN\n    }\n\n    return -(hours * MILLISECONDS_IN_HOUR)\n  }\n\n  // ±hh:mm or ±hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    var minutes = parseInt(token[2], 10)\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN\n    }\n\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\n    return hours > 0 ? -absoluteOffset : absoluteOffset\n  }\n\n  // IANA time zone\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now())\n    var utcDate = isUtcDate ? date : toUtcDate(date)\n\n    var offset = calcOffset(utcDate, timezoneString)\n\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString)\n\n    return -fixedOffset\n  }\n\n  return NaN\n}\n\nfunction toUtcDate(date) {\n  return newDateUTC(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n    date.getSeconds(),\n    date.getMilliseconds()\n  )\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = tzTokenizeDate(date, timezoneString)\n\n  // ms dropped because it's not provided by tzTokenizeDate\n  var asUTC = newDateUTC(\n    tokens[0],\n    tokens[1] - 1,\n    tokens[2],\n    tokens[3] % 24,\n    tokens[4],\n    tokens[5],\n    0\n  ).getTime()\n\n  var asTS = date.getTime()\n  var over = asTS % 1000\n  asTS -= over >= 0 ? over : 1000 + over\n  return asUTC - asTS\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime()\n\n  // Our UTC time is just a guess because our offset is just a guess\n  var utcGuess = localTS - offset\n\n  // Test whether the zone matches the offset for this ts\n  var o2 = calcOffset(new Date(utcGuess), timezoneString)\n\n  // If so, offset didn't change, and we're done\n  if (offset === o2) {\n    return offset\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= o2 - offset\n\n  // If that gives us the local time we want, we're done\n  var o3 = calcOffset(new Date(utcGuess), timezoneString)\n  if (o2 === o3) {\n    return o2\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n  return Math.max(o2, o3)\n}\n\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || (0 <= minutes && minutes <= 59))\n}\n\nvar validIANATimezoneCache = {}\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true\n  try {\n    new Intl.DateTimeFormat(undefined, { timeZone: timeZoneString })\n    validIANATimezoneCache[timeZoneString] = true\n    return true\n  } catch (error) {\n    return false\n  }\n}\n","/** Regex to identify the presence of a time zone specifier in a date string */\nvar tzPattern = /(Z|[+-]\\d{2}(?::?\\d{2})?| UTC| [a-zA-Z]+\\/[a-zA-Z_]+(?:\\/[a-zA-Z_]+)?)$/\n\nexport default tzPattern\n","import toInteger from 'date-fns/_lib/toInteger/index.js'\nimport getTimezoneOffsetInMilliseconds from 'date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js'\nimport tzParseTimezone from '../_lib/tzParseTimezone/index.js'\nimport tzPattern from '../_lib/tzPattern/index.js'\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\nvar DEFAULT_ADDITIONAL_DIGITS = 2\n\nvar patterns = {\n  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,\n  datePattern: /^([0-9W+-]+)(.*)/,\n  plainTime: /:/,\n\n  // year tokens\n  YY: /^(\\d{2})$/,\n  YYY: [\n    /^([+-]\\d{2})$/, // 0 additional digits\n    /^([+-]\\d{3})$/, // 1 additional digit\n    /^([+-]\\d{4})$/, // 2 additional digits\n  ],\n  YYYY: /^(\\d{4})/,\n  YYYYY: [\n    /^([+-]\\d{4})/, // 0 additional digits\n    /^([+-]\\d{5})/, // 1 additional digit\n    /^([+-]\\d{6})/, // 2 additional digits\n  ],\n\n  // date tokens\n  MM: /^-(\\d{2})$/,\n  DDD: /^-?(\\d{3})$/,\n  MMDD: /^-?(\\d{2})-?(\\d{2})$/,\n  Www: /^-?W(\\d{2})$/,\n  WwwD: /^-?W(\\d{2})-?(\\d{1})$/,\n\n  HH: /^(\\d{2}([.,]\\d*)?)$/,\n  HHMM: /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n  HHMMSS: /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n\n  // time zone tokens (to identify the presence of a tz)\n  timeZone: tzPattern,\n}\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n * If the function cannot parse the string or the values are invalid, it returns Invalid Date.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = toDate('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * var result = toDate('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport default function toDate(argument, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  if (argument === null) {\n    return new Date(NaN)\n  }\n\n  var options = dirtyOptions || {}\n\n  var additionalDigits =\n    options.additionalDigits == null\n      ? DEFAULT_ADDITIONAL_DIGITS\n      : toInteger(options.additionalDigits)\n  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n    throw new RangeError('additionalDigits must be 0, 1 or 2')\n  }\n\n  // Clone the date\n  if (\n    argument instanceof Date ||\n    (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')\n  ) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (\n    typeof argument === 'number' ||\n    Object.prototype.toString.call(argument) === '[object Number]'\n  ) {\n    return new Date(argument)\n  } else if (\n    !(\n      typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]'\n    )\n  ) {\n    return new Date(NaN)\n  }\n\n  var dateStrings = splitDateString(argument)\n\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits)\n  var year = parseYearResult.year\n  var restDateString = parseYearResult.restDateString\n\n  var date = parseDate(restDateString, year)\n\n  if (isNaN(date)) {\n    return new Date(NaN)\n  }\n\n  if (date) {\n    var timestamp = date.getTime()\n    var time = 0\n    var offset\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time)\n\n      if (isNaN(time)) {\n        return new Date(NaN)\n      }\n    }\n\n    if (dateStrings.timeZone || options.timeZone) {\n      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time))\n      if (isNaN(offset)) {\n        return new Date(NaN)\n      }\n    } else {\n      // get offset accurate to hour in time zones that change offset\n      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time))\n      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset))\n    }\n\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(NaN)\n  }\n}\n\nfunction splitDateString(dateString) {\n  var dateStrings = {}\n  var parts = patterns.dateTimePattern.exec(dateString)\n  var timeString\n\n  if (!parts) {\n    parts = patterns.datePattern.exec(dateString)\n    if (parts) {\n      dateStrings.date = parts[1]\n      timeString = parts[2]\n    } else {\n      dateStrings.date = null\n      timeString = dateString\n    }\n  } else {\n    dateStrings.date = parts[1]\n    timeString = parts[3]\n  }\n\n  if (timeString) {\n    var token = patterns.timeZone.exec(timeString)\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '')\n      dateStrings.timeZone = token[1].trim()\n    } else {\n      dateStrings.time = timeString\n    }\n  }\n\n  return dateStrings\n}\n\nfunction parseYear(dateString, additionalDigits) {\n  var patternYYY = patterns.YYY[additionalDigits]\n  var patternYYYYY = patterns.YYYYY[additionalDigits]\n\n  var token\n\n  // YYYY or ±YYYYY\n  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString)\n  if (token) {\n    var yearString = token[1]\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length),\n    }\n  }\n\n  // YY or ±YYY\n  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString)\n  if (token) {\n    var centuryString = token[1]\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length),\n    }\n  }\n\n  // Invalid ISO-formatted year\n  return {\n    year: null,\n  }\n}\n\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n\n  var token\n  var date\n  var month\n  var week\n\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0)\n    date.setUTCFullYear(year)\n    return date\n  }\n\n  // YYYY-MM\n  token = patterns.MM.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n\n    if (!validateDate(year, month)) {\n      return new Date(NaN)\n    }\n\n    date.setUTCFullYear(year, month)\n    return date\n  }\n\n  // YYYY-DDD or YYYYDDD\n  token = patterns.DDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    var dayOfYear = parseInt(token[1], 10)\n\n    if (!validateDayOfYearDate(year, dayOfYear)) {\n      return new Date(NaN)\n    }\n\n    date.setUTCFullYear(year, 0, dayOfYear)\n    return date\n  }\n\n  // yyyy-MM-dd or YYYYMMDD\n  token = patterns.MMDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    var day = parseInt(token[2], 10)\n\n    if (!validateDate(year, month, day)) {\n      return new Date(NaN)\n    }\n\n    date.setUTCFullYear(year, month, day)\n    return date\n  }\n\n  // YYYY-Www or YYYYWww\n  token = patterns.Www.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n\n    if (!validateWeekDate(year, week)) {\n      return new Date(NaN)\n    }\n\n    return dayOfISOWeekYear(year, week)\n  }\n\n  // YYYY-Www-D or YYYYWwwD\n  token = patterns.WwwD.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    var dayOfWeek = parseInt(token[2], 10) - 1\n\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN)\n    }\n\n    return dayOfISOWeekYear(year, week, dayOfWeek)\n  }\n\n  // Invalid ISO-formatted date\n  return null\n}\n\nfunction parseTime(timeString) {\n  var token\n  var hours\n  var minutes\n\n  // hh\n  token = patterns.HH.exec(timeString)\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'))\n\n    if (!validateTime(hours)) {\n      return NaN\n    }\n\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n\n  // hh:mm or hhmm\n  token = patterns.HHMM.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseFloat(token[2].replace(',', '.'))\n\n    if (!validateTime(hours, minutes)) {\n      return NaN\n    }\n\n    return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\n  }\n\n  // hh:mm:ss or hhmmss\n  token = patterns.HHMMSS.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseInt(token[2], 10)\n    var seconds = parseFloat(token[3].replace(',', '.'))\n\n    if (!validateTime(hours, minutes, seconds)) {\n      return NaN\n    }\n\n    return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000\n  }\n\n  // Invalid ISO-formatted time\n  return null\n}\n\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  week = week || 0\n  day = day || 0\n  var date = new Date(0)\n  date.setUTCFullYear(isoWeekYear, 0, 4)\n  var fourthOfJanuaryDay = date.getUTCDay() || 7\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay\n  date.setUTCDate(date.getUTCDate() + diff)\n  return date\n}\n\n// Validation functions\n\nvar DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nvar DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)\n}\n\nfunction validateDate(year, month, date) {\n  if (month < 0 || month > 11) {\n    return false\n  }\n\n  if (date != null) {\n    if (date < 1) {\n      return false\n    }\n\n    var isLeapYear = isLeapYearIndex(year)\n    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {\n      return false\n    }\n    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction validateDayOfYearDate(year, dayOfYear) {\n  if (dayOfYear < 1) {\n    return false\n  }\n\n  var isLeapYear = isLeapYearIndex(year)\n  if (isLeapYear && dayOfYear > 366) {\n    return false\n  }\n  if (!isLeapYear && dayOfYear > 365) {\n    return false\n  }\n\n  return true\n}\n\nfunction validateWeekDate(year, week, day) {\n  if (week < 0 || week > 52) {\n    return false\n  }\n\n  if (day != null && (day < 0 || day > 6)) {\n    return false\n  }\n\n  return true\n}\n\nfunction validateTime(hours, minutes, seconds) {\n  if (hours != null && (hours < 0 || hours >= 25)) {\n    return false\n  }\n\n  if (minutes != null && (minutes < 0 || minutes >= 60)) {\n    return false\n  }\n\n  if (seconds != null && (seconds < 0 || seconds >= 60)) {\n    return false\n  }\n\n  return true\n}\n","import cloneObject from 'date-fns/_lib/cloneObject/index.js'\nimport toDate from '../toDate/index.js'\nimport tzPattern from '../_lib/tzPattern/index.js'\nimport tzParseTimezone from '../_lib/tzParseTimezone/index.js'\nimport newDateUTC from '../_lib/newDateUTC/index.js'\n\n/**\n * @name zonedTimeToUtc\n * @category Time Zone Helpers\n * @summary Get the UTC date/time from a date representing local time in a given time zone\n *\n * @description\n * Returns a date instance with the UTC time of the provided date of which the values\n * represented the local time in the time zone specified. In other words, if the input\n * date represented local time in time time zone, the timestamp of the output date will\n * give the equivalent UTC of that local time regardless of the current system time zone.\n *\n * @param {Date|String|Number} date - the date with values representing the local time\n * @param {String} timeZone - the time zone of this local time, can be an offset or IANA time zone\n * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Date} the new date with the equivalent time in the time zone\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // In June 10am in Los Angeles is 5pm UTC\n * const result = zonedTimeToUtc(new Date(2014, 5, 25, 10, 0, 0), 'America/Los_Angeles')\n * //=> 2014-06-25T17:00:00.000Z\n */\nexport default function zonedTimeToUtc(date, timeZone, options) {\n  if (typeof date === 'string' && !date.match(tzPattern)) {\n    var extendedOptions = cloneObject(options)\n    extendedOptions.timeZone = timeZone\n    return toDate(date, extendedOptions)\n  }\n\n  var d = toDate(date, options)\n\n  var utc = newDateUTC(\n    d.getFullYear(),\n    d.getMonth(),\n    d.getDate(),\n    d.getHours(),\n    d.getMinutes(),\n    d.getSeconds(),\n    d.getMilliseconds()\n  ).getTime()\n\n  var offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc))\n\n  return new Date(utc + offsetMilliseconds)\n}\n"],"names":["Object","defineProperty","exports","value","target","object","TypeError","property","prototype","hasOwnProperty","call","module","default","_interopRequireDefault","require","_index","date","utcDate","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","setUTCFullYear","getTime","dirtyNumber","NaN","number","Number","isNaN","Math","ceil","floor","tzTokenizeDate","timeZone","dtf","dtfCache","testDateFormatted","Intl","DateTimeFormat","hour12","year","month","day","hour","minute","second","format","hourCycleSupported","hourCycle","getDateTimeFormat","formatToParts","formatted","filled","i","length","pos","typeToPos","type","parseInt","error","RangeError","partsOffset","replace","parsed","exec","hackyOffset","newDateUTC","fullYear","millisecond","setUTCHours","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","tzParseTimezone","timezoneString","isUtcDate","token","absoluteOffset","hours","validateTimezone","minutes","abs","timeZoneString","validIANATimezoneCache","undefined","isValidTimezoneIANAString","now","toUtcDate","offset","calcOffset","fixedOffset","localTS","utcGuess","o2","o3","max","fixOffset","tokens","asUTC","asTS","over","DEFAULT_ADDITIONAL_DIGITS","dateTimePattern","datePattern","plainTime","YY","YYY","YYYY","YYYYY","MM","DDD","MMDD","Www","WwwD","HH","HHMM","HHMMSS","tzPattern","toDate","argument","dirtyOptions","arguments","options","additionalDigits","toInteger","toString","dateStrings","dateString","timeString","parts","time","trim","splitDateString","parseYearResult","patternYYY","patternYYYYY","yearString","restDateString","slice","centuryString","parseYear","week","validateDate","dayOfYear","isLeapYear","isLeapYearIndex","validateDayOfYearDate","validateWeekDate","dayOfISOWeekYear","dayOfWeek","parseDate","timestamp","validateTime","parseFloat","seconds","parseTime","getTimezoneOffsetInMilliseconds","isoWeekYear","diff","getUTCDay","setUTCDate","getUTCDate","DAYS_IN_MONTH","DAYS_IN_MONTH_LEAP_YEAR","zonedTimeToUtc","match","extendedOptions","cloneObject","d","utc","offsetMilliseconds"],"sourceRoot":""}